虽然**object构造函数**或**对象字面量**都可以创建单个对象，但是这些方式有个很明显的缺点：使用同一个接口会创建很多对象，会重复大量代码。工厂模式就是解决这个问题。
## 一、工厂模式
考虑到JavaScript无法创建类，所以用一种**函数**来封装以特定接口创建对象的细节。

```javascript
function createFan(name,sex,age){
	var obj=new Object();
	obj.name=name;
	obj.sex=sex;
	obj.age=age;
	obj.sayName=()=>{
		console.log(this.name)
	};
	return obj;
}
var Fan1=createFan("fan","girl","21")
console.log(Fan1)
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200118211343917.png)
根据**接收的参数**来构建一个包含所有必要信息的**对象**，可以无数次调用该函数，每个对象都会包括该函数里的所有属性和方法。

优缺点：解决了创建多个相似对象的问题，却没有解决对象识别的问题（怎么样知道一个对象的类型）
## 二、构造函数模式
构造函数可用来**创建特定类型的对象**
自定义构造函数：
- 1、构造函数首字母必须大写，非构造函数首字母小写
- 2、必须使用new操作符
```javascript
function CreateFan(name,sex,age){
	this.name=name;
	this.sex=sex;
	this.age=age;
	this.sayName=()=>{
		console.log(this.name);
	}
};
var Fan1=new CreateFan("fan","girl","21");
console.log(Fan1)
```
#### 1、constructor属性
标识对象类型（解决工厂模式的问题），但是检测对象类型一般还是使用instanceof操作符
在上述例子中，constructor属性指向CreateFan

```javascript
console.log(Fan1.constructor==CreateFan)   //true
console.log(Fan1.constructor)
console.log(CreateFan.constructor)
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312111419314.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312111433878.png)
#### 2、构造函数与其他函数的区别
调用方式不同：任何函数只要通过new操作符调用就是构造函数，任何函数不通过new操作符调用就和普通函数没区别

```javascript
//构造函数
var Fan1=new CreateFan("fan","girl","21");
Fan1.sayName()   //fan
//普通函数
CreateFan("meng","man","20")
window.sayName()   //meng
```
#### 3、构造函数的缺点
构造函数的方法都要在每个实例上重新创建一遍，例如Fan1和Fan2的sayName()方法**不是同一个Function的实例**。

```javascript
var Fan1=new CreateFan("fan","girl","21");
var Fan2=new CreateFan("fan","girl","21");
console.log(Fan1.name===Fan2.name)   //true
console.log(Fan1.sayName===Fan2.sayName)   //false
```
如果将sayName()方法提取出来，那么sayName()就变成了一个全局函数，但是这个**全局函数只能被某一个对象调用**，就失去了全局函数本身的意义，而且如果一个对象有很多种方法，那么就要创建很多个全局函数。

```javascript
function CreateFan(name, sex, age) {
	this.name = name;
	this.sex = sex;
	this.age = age;
	this.sayName=sayName;
};
function sayName(){
	console.log(this.name)
}
var Fan1 = new CreateFan("fan", "girl", "21");
var Fan2 = new CreateFan("fan", "girl", "21");
console.log(Fan1.name === Fan2.name)  //true
console.log(Fan1.sayName === Fan2.sayName)  //true
```

## 三、原型模式
解决了构造函数的缺点
#### 1、prototype属性
这个属性是一个指针，指向一个对象。prototype就是通过调用**构造函数**而创建的那个对象实例的**原型对象**。使用原型对象的好处就是可以让所有对象实例共享它所包含的属性和方法。所以原型模式就是不必在**构造函数**中定义对象实例的信息，可以直接将信息添加到**原型对象**中。

```javascript
function CreateFan() {}
CreateFan.prototype.name = "fan";
CreateFan.prototype.sex = "girl";
CreateFan.prototype.age = "21";
// 使用es6语法this会指向window
CreateFan.prototype.sayName = function() {
	console.log(this.name)
}
var Fan1 = new CreateFan();
var Fan2 = new CreateFan();
console.log(Fan1.sayName===Fan2.sayName)  //true
```
将所有属性和方法都添加到prototype属性中，构造函数变成了空函数，但是也可以通过调用构造函数来创建新对象，新对象所有的属性和方法都是由所有实例共享。
#### 2、原型对象
无论何时，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个**prototype属性**，prototype属性就会**指向函数的原型对象**。在默认情况下，所有**原型对象**都会获得**constructor（构造函数）属性**，该属性是一个**指向prototype属性所在函数**的指针。

```javascript
console.log(Fan1.constructor===CreateFan.prototype.constructor)  //true
console.log(CreateFan===CreateFan.prototype.constructor)  //true
```

当调用**构造函数**创建一个新实例之后，该实例的内部将包含一个指针（**内部属性**[[prototype]]），**指向构造函数的原型对象**

（1）isPrototypeOf()：因为所有**实例**中都无法访问到[[prototype]]，但是可以通过isPrototypeOf()方法，确定对象之间是否存在关系。如果[[prototype]]指向调用isPrototypeOf()方法的对象（CreateFan.prototype），则返回true

```javascript
console.log(CreateFan.prototype.isPrototypeOf(Fan1))  //true
```
（2）Object.getPrototypeOf()：ES5新增的方法，可以返回[[prototype]]的值。调用Object.getPrototypeOf()方法返回的对象实际上就是这个对象的原型。这个方法对**原型继承**来说很重要

```javascript
console.log(Object.getPrototypeOf(Fan1))
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312135442267.png)
注意：虽然可以通过对象**实例**访问原型中的值，但是不能通过对象实例**重写**原型中的值。如果我们在对象实例中新定义一个与原型属性名一样的属性，那么就会在实例中创建该属性，并对原型的该属性进行**覆盖**。
当访问Fan1.name时，首先会在**实例**上搜索一个名叫name的属性，在实例上找不到，则会去搜索**原型**，是否存在该属性。如果在实例上找到了，就不必去搜索原型了。
```javascript
console.log(Fan1.name)  //fan
Fan1.name = "yu";
console.log(Fan1.name)  //yu
//使用delete操作符可以删除实例属性，从而访问原型中的name属性
delete Fan1.name;
console.log(Fan1.name)  //fan
```
（3）hasOwnProperty()：这个方法是从Object中继承来的。用于检测一个属性是存在于实例中还是原型中，存在实例中返回true，存在原型中返回false

```javascript
console.log(Fan1.hasOwnProperty("name"))  //false
```

（4）in操作符，有两种使用方法：单独使用或在for-in循环中使用
单独使用in操作符可判断该属性是否存在**对象**中，无论该属性是存在于原型还是实例中。
```javascript
console.log("name" in Fan1)   //true
```
**同时使用**hasOwnProperty()方法和in操作符可确定该属性是存在对象实例还是原型中
```javascript
function check(object,name){
	return !object.hasOwnProperty(name) && (name in object)
}
console.log(check(Fan1,"name"))
```
使用for-in循环时，返回的是所有能够通过对象访问的、**可枚举**的属性。其中既包括在实例中的属性，也包括在原型中的属性，即使是屏蔽了原型中不可枚举属性（[[Enumerable]]为false）的**实例属性**也可以被返回。

```javascript
var o={
	toString:function(){
		return "my object";
	}
};
for(var prop in o){
	if(prop=="toString"){
		alert("found")
	}
}
```

不可枚举的属性和方法有：hasOwnProperty()、propertyIsEnumerable()、toLocalString()、toString()、valueOf()、constructor、prototype
（5）Object.keys()方法可以获得对象中所有可枚举的实例属性
（6）Object.hasOwnPropertyNames()方法可以返回所有实例属性，不管是不是被枚举是属性。
Object.hasOwnPropertyNames()和Object.keys()方法都可以替代for-in循环

#### 简化的原型语法
```javascript
function CreateFan(){}
CreateFan.prototype={
	name:"Fan",
	sex:"girl",
	age:"21",
	sayName:function(){
		console.log(this.name)
	}
}
var Fan1=new CreateFan();
Fan1.sayName()
```
问题是：constructor属性不指向CreateFan了。**因为每创建一个函数，就会同时创建prototype对象，这个对象会自动获得constructor属性**，但是在这里完全重写了prototype对象，因此constructor就指向了Object构造函数，constructor已经无法确定对象的类型了。因此我们可以将constructor特意指向适当的值（但是会导致[[Enumerable]]被设置为true）。

```javascript
CreateFan.prototype={
    //导致[[Enumerable]]被设置为true
	constructor:CreateFan,
	name:"Fan",
	sex:"girl",
	age:"21",
	sayName:function(){
		console.log(this.name)
	}
}
```
如果想要兼容ES5的JavaScript引擎，可以使用Object.defineProperty()

```javascript
function CreateFan(){}
CreateFan.prototype={
	name:"Fan",
	sex:"girl",
	age:"21",
	sayName:function(){
		console.log(this.name)
	}
}
Object.defineProperty(CreateFan.prototype,"constructor",{
	enumerable:false,
	value:CreateFan
})
```
#### 原型的动态性
如果先创建一个实例，再在原型中添加属性或方法，是不会出错的。因为实例和原型之间存在松散连接关系。但是重写整个原型对象，就会报错。
#### 原生对象的原型
原生引用类型有Object、Array、String
#### 原型模式的缺点
所有实例在默认下都会取得相同的属性值。最大的问题是其**共享**的本性造成的。
原型中所有属性都是共享的，这对定义的函数非常合适，对包含基本值的属性也可以接受，但是对于**包含引用类型值的属性**来说问题比较突出。

```javascript
function CreateFan(){}
CreateFan.prototype={
	age:"21",
	friend:["a","b"],
	sayName:function(){
		console.log(this.name)
	}
}
var Fan1=new CreateFan();
var Fan2=new CreateFan();
Fan1.friend.push("c");
console.log(Fan1.friend)  //["a","b","c"]
console.log(Fan2.friend)  //["a","b","c"]
```

## 组合使用构造函数模式和原型模式
创建自定义类型最常见的方式就是组合使用构造函数模式和原型模式
构造函数模式用于定义实例的属性
原型模式用于定义实例的方法和共享属性
