# 什么是响应式对象？

Vue.js 实现响应式的核心是利用了 ES5 的 `Object.defineProperty`。因为 IE8 及以下浏览器没有`Object.defineProperty`方法，这也是为什么 Vue.js 不能兼容 IE8 及以下浏览器的原因。

## Object.defineProperty

```javascript
Object.defineProperty(obj, prop, descriptor)
```

`obj`是要在其上定义属性的对象。
`prop`是要定义或修改的属性的名称。
`descriptor`是将被定义或修改的属性描述符。一旦对象拥有了`getter`和`setter`属性，我们可以简单地把这个对象称为**响应式对象**。`get`是一个给属性提供的`getter`方法，当我们访问了该属性的时候会触发`getter`方法；`set`是一个给属性提供的`setter`方法，当我们对该属性做修改的时候会触发`setter`方法。

那么 Vue.js 把哪些对象变成了响应式对象了呢，可以从源码层面分析。

### 源码部分

#### src\core\instance\init.js

初始化 Vue 时会调用`_init`方法，`init`方法中有`initState()`方法。

#### src\core\instance\state.js

（1）initState

该方法主要是初始化`props`、`methods`、`data`、`computed`和 `wathcer`等属性做了初始化操作。

```javascript
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```

重点分析`initProps()`和`initData()`

（2）initProps

调用`defineReactive()`方法把每个`props`的`key`变成响应式

```javascript
function initProps (vm: Component, propsOptions: Object) {
  const propsData = vm.$options.propsData || {}
  const props = vm._props = {}
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  const keys = vm.$options._propKeys = []
  const isRoot = !vm.$parent
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false)
  }
  for (const key in propsOptions) {
    keys.push(key)
    const value = validateProp(key, propsOptions, propsData, vm)
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      const hyphenatedKey = hyphenate(key)
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          `"${hyphenatedKey}" is a reserved attribute and cannot be used as component prop.`,
          vm
        )
      }
      defineReactive(props, key, value, () => {
        if (!isRoot && !isUpdatingChildComponent) {
          warn(
            `Avoid mutating a prop directly since the value will be ` +
            `overwritten whenever the parent component re-renders. ` +
            `Instead, use a data or computed property based on the prop's ` +
            `value. Prop being mutated: "${key}"`,
            vm
          )
        }
      })
    } else {
      defineReactive(props, key, value)
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, `_props`, key)
    }
  }
  toggleObserving(true)
}
```

（3）initData

遍历所有的`Object.keys(data)`，在`methods`或`props`中定义了就会报警告。

```javascript
function initData (vm: Component) {
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  if (!isPlainObject(data)) {
    data = {}
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }
  // proxy data on instance
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn(
          `Method "${key}" has already been defined as a data property.`,
          vm
        )
      }
    }
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${key}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) {
      proxy(vm, `_data`, key)
    }
  }
  // observe data
  observe(data, true /* asRootData */)
}
```

# 响应式对象的创建过程